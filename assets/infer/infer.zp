(define (find-binding env bind)
  (if (list? bind)
    (let ((name (car bind)))
      (if (in? env name)
        (list:last (env name))
        :unknown))
    (if (in? env bind)
      (env bind)
      :unknown)))

(define env
  #{"+" (:integer :integer :integer)
    "-" (:integer :integer :integer)
    "*" (:integer :integer :integer)
    "/" (:integer :integer :integer)})

(define (infer-expression expr . env)
  (let* ((env (if (null? env) #{} (car env)))
         (return (lambda (x) (list x env))))
    (cond
      ((atom? expr) (return :atom))
      ((hash-map? expr) (return :hash-map))
      ((vector? expr) (return :vector))
      ((byte-vector? expr) (return :byte-vector))
      ((symbol? expr)
        (let ((sexpr (->string expr)))
          (if (in? env sexpr)
            (let ((res (infer-expression (env sexpr) env)))
                (list (car res) (hash:set env sexpr (car res))))
            (return :unbound))))
      ((simple? expr) (return (string->symbol (++ ":" (typeof expr)))))
      (else (infer-special expr env)))))

(define (infer-special expr env)
  (case (car expr)
    ((quote)
      (list :list env))
    ((begin)
      (let ((sub (infer-program (cdr expr) env)))
        (list (car (infer-expression (list:last (cdr expr)) sub)) sub)))
    ((lambda)
      (let* ((sub (infer-expression (caddr expr) env))
             (type (++ (map (curry find-binding (cadr sub)) (cadr expr))
                       (car sub))))
        (list type env)))
    ((define)
      (infer-define expr env))
    (else
      (let ((name (->string (car expr))))
        (if (in? env name)
          (let ((type (env name)))
            (if (list? type)
              (let ((nenv (reduce (lambda (lenv tuple)
                              (let ((binds (car lenv))
                                    (env (cadr lenv)))
                                (if (eq? 2 (length tuple))
                                  (let ((name (car tuple)))
                                    (if (not (symbol? name))
                                      (let ((b (infer-expression name)))
                                        (list (++ binds (car b)) env))
                                      (let ((name (->string name))
                                            (type (cadr tuple)))
                                        (if (and (in? env name) (not (eq? (env name) :unknown)))
                                          (if (or (eq? (env name) type) (eq? type :unknown))
                                            (list (++ binds (env name)) env)
                                            (list (++ binds type) (hash:set env name :ambiguous)))
                                          (list (++ binds type) (hash:set env name type))))))
                                  lenv)))
                             (list [] env)
                             (zip-with (lambda (x y) (list (list x y))) (cdr expr) type))))
                (list (list:last type) (hash:update (cadr nenv)
                                                    name
                                                    (lambda (val)
                                                      (if (eq? (length val)
                                                               (add1 (length (car nenv))))
                                                        (++ (car nenv) (list:last val))
                                                        val)))))
              (list :recurse env)))
          (list :unbound env))))))

(define-syntax define-typed
  (syntax-rules ()
    ((_ h b)
      (let* ((name (car 'h))
             (args (cdr 'h))
             (env (reduce (lambda (env el) (hash:set env (->string el) :unknown)) env args))
             (sub (infer-expression 'b (hash:set env (->string name) :recurse)))
             (type (++ (map (curry find-binding (cadr sub)) args)
                       (car sub))))
        (begin
          (write type)
          (write (hash:set env (->string name) type))
          (define h b))))))
